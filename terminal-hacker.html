<!DOCTYPE html>
<html lang="pt-BR">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>PROTOCOL 2M - SHELL</title>
   <!-- Incluindo Tailwind CSS para estilização rápida e minimalista -->
   <script src="https://cdn.tailwindcss.com"></script>
   <style>
       /* Estilos altamente minimalistas, imitando um terminal */
       body {
           background-color: #000000; /* Fundo Preto */
           color: #ffffff; /* Texto Padrão Branco */
           font-family: 'Monospace', 'Courier New', monospace; /* Fonte sem serifa para parecer terminal */
           height: 100vh;
           margin: 0;
           display: flex;
           flex-direction: column;
           overflow: hidden; /* Evita a barra de rolagem no corpo */
           padding: 1rem;
       }

       /* Cores conforme solicitado */
       .color-white { color: #ffffff; }
       .color-green { color: #10B981; /* Tailwind emerald-500 */ }
       .color-red { color: #EF4444; /* Tailwind red-500 */ }
       .color-blue { color: #3B82F6; /* Tailwind blue-500 */ }
       .color-yellow { color: #F59E0B; /* Tailwind amber-500 */ }
       .color-orange { color: #F97316; /* Tailwind orange-500 */ }

       #output {
           flex-grow: 1;
           overflow-y: auto;
           max-height: calc(100vh - 4rem); /* Altura máxima para a área de saída */
           white-space: pre-wrap; /* Preserva formatação e quebra de linha */
           padding-bottom: 1rem;
       }

       #input-line {
           display: flex;
           align-items: center;
       }

       #input-line input {
           flex-grow: 1;
           background: #000000;
           border: none;
           color: #ffffff;
           outline: none;
           padding: 0;
           font-family: inherit;
           font-size: inherit;
       }
   </style>
</head>
<body>

   <!-- Área de Saída (Output) -->
   <div id="output" class="text-sm md:text-base"></div>

   <!-- Linha de Comando (Input) -->
   <div id="input-line" class="text-sm md:text-base">
       <span class="color-green mr-2">USER@PROTOCOL_SHELL:</span>
       <input type="text" id="commandInput" autofocus onkeydown="handleInput(event)">
   </div>

   <script>
       // Variáveis Globais (Estado do Jogo)
       let balance = 1000.00; // Saldo inicial em Reais
       let dangerLevel = 0; // Nível de Perigo (0-100)
       let traceStatus = 0; // 0: None, 1: Low Trace, 2: High Trace
       const WIN_TARGET = 2000000.00; // Meta Final: R$ 2 milhões
       const TRANSITION_TARGET = 1000000.00; // Meta de Transição: R$ 1 milhão
       const MAX_DANGER = 100;
       
       // --- Requisitos de Upgrade ---
       // Nível MÁXIMO (individual) para upgrades
       const MAX_UPGRADE_LEVEL = 3; 
       // Nível TOTAL combinado para alcançar a Meta de Transição (Primeira Meta)
       const TRANSITION_UPGRADE_TOTAL_LEVEL_REQ = 3;
       // Nível MÁXIMO (individual) para vencer o jogo (Meta Final)
       const WIN_UPGRADE_LEVEL_REQ = MAX_UPGRADE_LEVEL; 
       // -----------------------------

       // Variáveis de Progressão (Upgrades) e Cooldown
       let lastHackTime = 0;
       const HACK_COOLDOWN_SECONDS = 3;
       let upgrade = {
           stealth: { level: 0, cost: 100000, max: MAX_UPGRADE_LEVEL, successBonus: 15, reduction: 0.8, name: "STEALTH CLOAK" }, 
           exploit: { level: 0, cost: 150000, max: MAX_UPGRADE_LEVEL, successBonus: 3, name: "EXPLOIT DB" } 
       };

       const BANK_UNLOCK_LEVEL = 1; 
       const TRACE_TRIGGER_DANGER = 50;
       const TRACE_COST_BASE = 50000; 
       const LAUNDERING_COST_PER_DANGER_POINT = 20000; // CUSTO LINEAR: R$20.000 para 1% de redução de Danger.

       const outputDiv = document.getElementById('output');
       const inputField = document.getElementById('commandInput');

       // --- Funções de Ajuda ---

       /**
        * Calcula o total de níveis de upgrades investidos.
        * @returns {number} O nível total combinado.
        */
       function getCurrentTotalUpgradeLevel() {
           let total = 0;
           for (const key in upgrade) {
               total += upgrade[key].level;
           }
           return total;
       }

       /**
        * Checa se o nível atual de TODOS os upgrades atinge o requisito mínimo individual.
        * Usado para a Meta Final (Lv 3 em tudo).
        * @param {number} requiredLevel - O nível mínimo exigido.
        * @returns {boolean} True se todos os módulos atingirem o nível, False caso contrário.
        */
       function checkIndividualUpgradeRequirements(requiredLevel) {
           for (const key in upgrade) {
               if (upgrade[key].level < requiredLevel) {
                   return false;
               }
           }
           return true;
       }
       
       /**
        * Checa se o nível atual TOTAL de upgrades atinge o requisito mínimo combinado.
        * Usado para a Meta de Transição (Primeira Meta).
        * @param {number} requiredTotal - O nível total exigido.
        * @returns {boolean} True se o total combinado for igual ou maior que o exigido.
        */
       function checkTotalUpgradeRequirements(requiredTotal) {
           return getCurrentTotalUpgradeLevel() >= requiredTotal;
       }


       /**
        * Determina a fase atual do jogo e retorna o multiplicador de dificuldade.
        * Infraestrutura de Baixo Valor (Fase 1): balance < 1M OU requisito de upgrade não cumprido. Multiplicador 1.0.
        * Infraestrutura de Alto Valor (Fase 2): balance >= 1M E requisito de upgrade cumprido. Multiplicador 1.5.
        * @returns {number} Multiplicador de 1.0 ou 1.5.
        */
       function getPhaseMultiplier() {
           // Se o saldo for maior ou igual à meta de transição E o total de upgrades for 3 ou mais, ative a Fase 2.
           if (balance >= TRANSITION_TARGET && checkTotalUpgradeRequirements(TRANSITION_UPGRADE_TOTAL_LEVEL_REQ)) {
                return 1.5;
           }
           // Caso contrário, permanece na Fase 1.
           return 1.0; 
       }

       /**
        * Adiciona uma linha formatada ao terminal.
        * @param {string} text - O texto a ser exibido.
        * @param {string} colorClass - A classe CSS de cor (e.g., 'color-green', 'color-red').
        */
       function print(text, colorClass = 'color-white') {
           const line = document.createElement('div');
           line.innerHTML = `<span class="${colorClass}">${text}</span>`;
           outputDiv.appendChild(line);
           // Rola automaticamente para o fim
           outputDiv.scrollTop = outputDiv.scrollHeight;
       }

       /**
        * Formata um valor numérico para a moeda brasileira (R$).
        * @param {number} value - O valor a ser formatado.
        * @returns {string} O valor formatado.
        */
       function formatCurrency(value) {
           return new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(value);
       }

       /**
        * Checa as condições de vitória ou derrota (ser pego).
        */
       function checkGameState() {
           // 1. Checagem de Derrota (Ser Pego)
           if (dangerLevel > 50) {
               const catchChance = Math.floor(Math.random() * 100);
               let catchThreshold = dangerLevel - 50; 

               if (catchChance < catchThreshold) {
                   print("================================================", 'color-red');
                   print("!!! ALERTA DE SEGURANÇA MÁXIMO: RASTREIO ATIVO !!!", 'color-red');
                   print("ERRO 0x011B: Rastreamento concluído. Firewall falhou.", 'color-red');
                   print(`REDE COMPROMETIDA. DANGER LEVEL: ${dangerLevel}%.`, 'color-red');
                   print("ERRO FATAL: AS AUTORIDADES CHEGARAM. TERMINAL BLOQUEADO.", 'color-red');
                   print("Game Over. Você foi pego.", 'color-white');
                   inputField.disabled = true;
                   return true;
               }
           }

           // 2. Checagem de Vitória (Bloqueio ou Sucesso na Meta Final)
           if (balance >= WIN_TARGET) {
               if (checkIndividualUpgradeRequirements(WIN_UPGRADE_LEVEL_REQ)) {
                   // Vitória - Requisito Cumprido (Lv 3 em tudo)
                   print("================================================", 'color-green');
                   print(">>> [SUCCESS] META FINAL ATINGIDA E INFRAESTRUTURA COMPLETA.", 'color-green');
                   print("... SALDO FINAL: " + formatCurrency(balance) + ".", 'color-green');
                   print("... INICIANDO PAYLOAD DE AUTODESTRUIÇÃO E EVASÃO.", 'color-green');
                   print("... 0x000010: Executando Modulo Stealth. Exit 0.", 'color-green');
                   print("... 0x000011: Chaves Deletadas. Conexão Encerrada.", 'color-green');
                   print("PROTOCOL 2M CONCLUÍDO. VOCÊ DESAPARECEU.", 'color-green');
                   print("Fim do Jogo.", 'color-white');
                   inputField.disabled = true;
                   return true;
               } else {
                   // Bloqueio de Vitória - Requisito Não Cumprido
                   print("================================================", 'color-red');
                   print("!!! ALERTA: META FINAL ATINGIDA, MAS REQUISITOS DE MÓDULO PENDENTES !!!", 'color-red');
                   print(`A infraestrutura não está segura para o escape. Nível máximo (${WIN_UPGRADE_LEVEL_REQ}) em todos os upgrades é obrigatório.`, 'color-red');
                   print("Use 'upgrade' (sem argumentos) para checar o progresso.", 'color-red');
                   print(`SALDO BLOQUEADO EM ${formatCurrency(WIN_TARGET)}.`, 'color-red');
                   balance = WIN_TARGET; // Garante que o saldo não ultrapasse a meta
                   return false;
               }
           }

           // 3. Checagem de Transição (Bloqueio ou Ativação da Fase 2)
           const isTransitionReqMet = checkTotalUpgradeRequirements(TRANSITION_UPGRADE_TOTAL_LEVEL_REQ);
           const currentPhaseMultiplier = getPhaseMultiplier();

           if (balance >= TRANSITION_TARGET) {
               if (!isTransitionReqMet) {
                   // Bloqueio de Transição - Requisito Não Cumprido
                   print("================================================", 'color-orange');
                   print("!!! ALERTA DE PROGRESSÃO: META DE TRANSIÇÃO ATINGIDA !!!", 'color-orange');
                   print(`REQUISITO DE MÓDULO: Nível TOTAL de ${TRANSITION_UPGRADE_TOTAL_LEVEL_REQ} é necessário para ativar a Infraestrutura de Alto Valor.`, 'color-orange');
                   print("Use 'upgrade' (sem argumentos) para ver o progresso (Total Atual: " + getCurrentTotalUpgradeLevel() + ").", 'color-orange');
                   print(`SALDO TEMPORARIAMENTE BLOQUEADO EM ${formatCurrency(TRANSITION_TARGET)}.`, 'color-orange');
                   balance = TRANSITION_TARGET; // Garante que o saldo não ultrapasse a meta até o requisito ser cumprido.
               } else if (currentPhaseMultiplier === 1.5) {
                    // Alerta de ativação da Fase 2 (só deve ocorrer na primeira vez após desbloqueio)
                    // NOTA: Esta mensagem só será impressa se o multiplier mudar de 1.0 para 1.5.
                   print("================================================", 'color-green');
                   print(">>> [INFRASTRUCTURE ONLINE] META DE TRANSIÇÃO CUMPRIDA.", 'color-green');
                   print("INFRAESTRUTURA DE ALTO VALOR ATIVADA! Riscos e Ganhos agora escalados em 1.5x.", 'color-green');
                   print("================================================", 'color-green');
               }
           }

           return false;
       }

       /**
        * Exibe a lista de comandos.
        */
       function showHelp() {
           print("================================================", 'color-blue');
           print("Lista de Comandos [PROTOCOL 2M]:", 'color-blue');
           print(" - status    : Exibe o saldo [BRL], a Meta e o Nível de Perigo [DANGER/TRACE].", 'color-white');
           print(" - hack <alvo> : Tenta uma invasão para ganhar dinheiro (COOLDOWN de 3s).", 'color-white');
           print("       Alvos: crypto (Baixo), corp (Médio), bank (Alto) - REQUER UPGRADE.", 'color-yellow');
           print(` - laundering <valor> : 'Lava' o dinheiro para reduzir o Perigo (1% DANGER a cada ${formatCurrency(LAUNDERING_COST_PER_DANGER_POINT)}).`, 'color-white'); 
           print(" - upgrade <modulo> : Investe em melhorias permanentes. Módulos: stealth, exploit.", 'color-yellow');
           print(" - upgrade : (Sem argumentos) Exibe informações detalhadas de custo e efeito dos módulos e Requisitos de Meta.", 'color-yellow');
           print(" - obfuscate : Tenta limpar um Rastreamento de Emergência (TRACE) ativo.", 'color-orange');
           print(" - clear     : Limpa a tela do terminal.", 'color-white');
           print(" - help      : Exibe esta lista de comandos.", 'color-white');
           print(" - exit      : Encerra a sessão.", 'color-white');
           print("================================================", 'color-blue');
       }

       /**
        * Exibe informações detalhadas sobre os módulos de upgrade e os requisitos de Meta.
        */
       function showUpgradeInfo() {
           print("================================================", 'color-blue');
           print("MÓDULOS DE UPGRADE DISPONÍVEIS:", 'color-blue');
           print("Use 'upgrade <modulo>' para investir e melhorar.", 'color-white');
           print("------------------------------------------------", 'color-white');

           // Itera sobre todos os módulos
           for (const key in upgrade) {
               const module = upgrade[key];
               const nextCost = (module.level < module.max) ? Math.floor(module.cost * Math.pow(2, module.level)) : null;
               const bonus = module.level * module.successBonus;
               let description = "";

               if (key === 'stealth') {
                   const currentReductionFactor = (1 - Math.pow(module.reduction, module.level));
                   const currentReductionPercentage = (currentReductionFactor * 100).toFixed(1);
                   description = `Otimiza a infraestrutura. Reduz o aumento de DANGER (${currentReductionPercentage}%) e aumenta a chance de Obfuscate (+${bonus}%).`;
               } else if (key === 'exploit') {
                   description = `Aprimora ferramentas de intrusão. Melhora a chance de sucesso em Hacks (+${bonus}%). Desbloqueia o alvo 'bank' no Nível ${BANK_UNLOCK_LEVEL}.`;
               }


               print(`[${module.name}] - Nível ${module.level}/${module.max}`, 'color-yellow');
               print(`   Função: ${description}`, 'color-white');
               if (nextCost !== null) {
                   print(`   Próx. Nível Custo: ${formatCurrency(nextCost)}`, 'color-green');
               } else {
                   print("   STATUS: Nível Máximo Alcançado.", 'color-green');
               }
               print("---", 'color-white');
           }

           // --- Requisitos de Meta (Novidade) ---
           print("REQUISITOS DE PROGRESSÃO (MÓDULOS):", 'color-blue');
           
           // Requisito de Transição
           print(`[PRIMEIRA META (TRANSIÇÃO) - ${formatCurrency(TRANSITION_TARGET)}]`, 'color-yellow');
           const transitionReqStatus = checkTotalUpgradeRequirements(TRANSITION_UPGRADE_TOTAL_LEVEL_REQ);
           print(`   Requerido: Nível TOTAL de upgrades deve ser ${TRANSITION_UPGRADE_TOTAL_LEVEL_REQ} (Total Atual: ${getCurrentTotalUpgradeLevel()}).`, transitionReqStatus ? 'color-green' : 'color-red');
           print(`   Status: ${transitionReqStatus ? 'CUMPRIDO' : 'PENDENTE'}`, transitionReqStatus ? 'color-green' : 'color-red');
           print("---", 'color-white');

           // Requisito de Vitória
           print(`[META FINAL (VITÓRIA) - ${formatCurrency(WIN_TARGET)}]`, 'color-yellow');
           const winReqStatus = checkIndividualUpgradeRequirements(WIN_UPGRADE_LEVEL_REQ);
           print(`   Requerido: Nível MÁXIMO (${WIN_UPGRADE_LEVEL_REQ}) em TODOS os módulos.`, winReqStatus ? 'color-green' : 'color-red');
           print(`   Status: ${winReqStatus ? 'CUMPRIDO' : 'PENDENTE'}`, winReqStatus ? 'color-green' : 'color-red');
           
           print("================================================", 'color-blue');
       }

       /**
        * Processa o comando 'status'.
        */
       function processStatus() {
           const currentPhaseMultiplier = getPhaseMultiplier();
           const phaseStatusText = currentPhaseMultiplier === 1.5 
               ? "INFRAESTRUTURA DE ALTO VALOR (RISCO: 1.5x)" 
               : "INFRAESTRUTURA DE BAIXO VALOR (RISCO: 1.0x)";

           print("================================================", 'color-blue');
           print("STATUS DE CONTA - [2M.protocol.runtime]:", 'color-blue');
           print(`SALDO [BRL]: ${formatCurrency(balance)}`, 'color-white');
           print(`PROGRESSO: ${phaseStatusText}`, currentPhaseMultiplier === 1.5 ? 'color-red' : 'color-yellow');
           
           // Exibir Trace Status
           let traceText, traceColor;
           if (traceStatus === 2) {
               traceText = "TRACE: ALTO (CRÍTICO)";
               traceColor = 'color-red';
           } else if (traceStatus === 1) {
               traceText = "TRACE: BAIXO (ATIVO)";
               traceColor = 'color-orange';
           } else {
               traceText = "TRACE: INATIVO (LIMPO)";
               traceColor = 'color-green';
           }
           print(`STATUS DE RASTREIO: ${traceText}`, traceColor);
           
           print(`PERIGO [DANGER]: ${dangerLevel}%`, dangerLevel > 70 ? 'color-red' : dangerLevel > 40 ? 'color-yellow' : 'color-green');
           
           // Exibir Metas
           print("--- METAS ---", 'color-blue');
           const nextTarget = balance < TRANSITION_TARGET ? TRANSITION_TARGET : WIN_TARGET;
           print(`PRÓXIMO OBJETIVO: ${formatCurrency(nextTarget)}`, 'color-yellow');

           // Alerta de requisitos pendentes
           if (balance >= TRANSITION_TARGET && !checkTotalUpgradeRequirements(TRANSITION_UPGRADE_TOTAL_LEVEL_REQ)) {
               print(`!!! REQUISITO PENDENTE: Nível TOTAL de ${TRANSITION_UPGRADE_TOTAL_LEVEL_REQ} de upgrade para avançar. !!!`, 'color-red');
           }
           if (balance >= WIN_TARGET && !checkIndividualUpgradeRequirements(WIN_UPGRADE_LEVEL_REQ)) {
               print(`!!! REQUISITO PENDENTE: Nível MÁXIMO (${WIN_UPGRADE_LEVEL_REQ}) em todos os upgrades para vencer. !!!`, 'color-red');
           }
           
           print("================================================", 'color-blue');
       }

       /**
        * Processa o comando 'hack <alvo>'.
        * @param {string[]} args - Argumentos do comando (o alvo).
        */
       function processHack(args) {
           // Checa se há um rastreamento ativo
           if (traceStatus > 0) {
               print("ERRO 0x00A1: OPERAÇÃO BLOQUEADA. Trace Event ativo. Execute 'obfuscate' primeiro.", 'color-red');
               return;
           }

           const target = args[0];

           // 1. Checagem de Cooldown
           const currentTime = Date.now();
           const timeElapsed = (currentTime - lastHackTime) / 1000;

           if (timeElapsed < HACK_COOLDOWN_SECONDS) {
               const remaining = Math.ceil(HACK_COOLDOWN_SECONDS - timeElapsed);
               print(`AVISO: Módulo 'intrusion_v2.1' em COOLDOWN. Aguarde ${remaining} segundos.`, 'color-yellow');
               return;
           }
           
           if (!target) {
               print("ERRO 0x001A: Comando 'hack' requer um alvo. Tente: hack <alvo>", 'color-red');
               print("Alvos disponíveis: crypto, corp, bank.", 'color-white');
               return;
           }

           // 2. Checagem de Bloqueio (Progressão Bloqueada)
           const isBankUnlocked = upgrade.exploit.level >= BANK_UNLOCK_LEVEL;
           if (target === 'bank' && !isBankUnlocked) {
               print(`ERRO 0x001C: ALVO BLOQUEADO. Acesso ao alvo 'bank' requer EXPLOIT DB Nível ${BANK_UNLOCK_LEVEL}.`, 'color-red');
               print("Use 'upgrade exploit' para desbloquear.", 'color-yellow');
               return;
           }


           const targets = {
               'bank': { risk: 30, gainMin: 80000, gainMax: 200000, danger: 15 },
               'corp': { risk: 20, gainMin: 30000, gainMax: 80000, danger: 8 },
               'crypto': { risk: 10, gainMin: 5000, gainMax: 20000, danger: 3 }
           };

           const selectedTarget = targets[target];

           if (!selectedTarget) {
               print(`ERRO 0x001B: Alvo '${target}' não reconhecido.`, 'color-red');
               return;
           }

           lastHackTime = currentTime; // Define o tempo do hack após a checagem
           const phaseMultiplier = getPhaseMultiplier(); // 1.0 ou 1.5

           print(`> [PYTHON SCRIPT] Executando 'intrusion_v2.1' contra ${target.toUpperCase()} (FATOR x${phaseMultiplier.toFixed(1)})...`, 'color-blue');

           // 3. Aplicar Bônus de Upgrade (Exploit DB)
           const exploitBonus = upgrade.exploit.level * upgrade.exploit.successBonus;
           const baseSuccess = 100 - selectedTarget.risk;
           const finalSuccess = baseSuccess - Math.floor(dangerLevel / 5) + exploitBonus; 
           const roll = Math.floor(Math.random() * 100) + 1;

           if (roll < finalSuccess) {
               // SUCESSO
               let gain = Math.floor(Math.random() * (selectedTarget.gainMax - selectedTarget.gainMin)) + selectedTarget.gainMin;
               
               // Aplicar Multiplicador de Ganho da Fase
               gain = Math.floor(gain * phaseMultiplier);

               // 4. Aplicar Penalidade de Perigo (Stealth Cloak + Phase Multiplier)
               const initialDanger = selectedTarget.danger;
               const stealthFactor = Math.pow(upgrade.stealth.reduction, upgrade.stealth.level);
               
               let actualDangerIncrease = Math.floor(initialDanger * stealthFactor * phaseMultiplier);
               actualDangerIncrease = Math.max(1, actualDangerIncrease); // Garante que o risco mínimo seja 1

               balance += gain;
               dangerLevel = Math.min(MAX_DANGER, dangerLevel + actualDangerIncrease);
               
               print(`...[200 OK] Transferência concluída. Tamanho do pacote: ${Math.floor(Math.random() * 500) + 100}kb.`, 'color-green');
               print(`...+${formatCurrency(gain)} adicionado. SALDO TOTAL: ${formatCurrency(balance)}.`, 'color-green');
               print(`...RISCO AJUSTADO: +${actualDangerIncrease} DANGER. (Stealth Lv. ${upgrade.stealth.level} | Infraestrutura x${phaseMultiplier.toFixed(1)})`, 'color-yellow');
           } else {
               // FALHA
               
               // O aumento de perigo na falha também é multiplicado pela fase
               let actualDangerIncrease = Math.max(1, Math.ceil(selectedTarget.danger / 2) * phaseMultiplier); 
               actualDangerIncrease = Math.max(1, Math.floor(actualDangerIncrease));

               dangerLevel = Math.min(MAX_DANGER, dangerLevel + actualDangerIncrease);
               
               print(`...[403 FORBIDDEN] Intrusion Detectada. Sistema de ${target} bloqueou o acesso.`, 'color-red');
               print("...ERRO 0x00A3: Nenhuma transação efetuada.", 'color-red');
               print(`...ALERTA: PING de Rastreamento Recebido (+${actualDangerIncrease} DANGER).`, 'color-yellow');

               // *** CHANCE DE TRACE EVENT APÓS FALHA ***
               if (dangerLevel >= TRACE_TRIGGER_DANGER) {
                   const traceRoll = Math.random();
                   if (traceRoll > 0.6) { // 40% de chance de trace low
                       traceStatus = 1;
                       print("!!! ALERTA TRACE EVENT !!! RASTREIO DETECTADO (NÍVEL BAIXO).", 'color-orange');
                       print("EXECUTE 'obfuscate' IMEDIATAMENTE.", 'color-orange');
                   } else if (traceRoll > 0.9) { // 10% de chance de trace high
                       traceStatus = 2;
                       print("!!! ALARME CRÍTICO !!! RASTREIO MASSIVO (NÍVEL ALTO).", 'color-red');
                       print("AÇÃO URGENTE NECESSÁRIA: 'obfuscate'.", 'color-red');
                   }
               }
           }
       }

       /**
        * Processa o comando 'laundering <valor>'.
        * @param {string[]} args - Argumentos do comando (o valor).
        */
       function processLaundering(args) {
           const amount = parseFloat(args[0]);

           if (isNaN(amount) || amount <= 0) {
               print("ERRO 0x002C: Valor inválido para lavagem. Sintaxe: laundering <valor>.", 'color-red');
               print("EXEMPLO: laundering 50000", 'color-red');
               return;
           }

           // Arredonda para baixo para múltiplos de 1000
           const roundedAmount = Math.floor(amount / 1000) * 1000;
           const cost = roundedAmount;

           if (cost > balance) {
               print("ERRO 0x002D: Saldo insuficiente. Requer: " + formatCurrency(cost) + " (arredondado).", 'color-red');
               return;
           }
           
           // CÁLCULO LINEAR: 1% de redução a cada R$20.000 investidos.
           const maxReduction = Math.floor(cost / LAUNDERING_COST_PER_DANGER_POINT); 
           const reduction = Math.min(dangerLevel, Math.max(0, maxReduction));

           if (reduction <= 0) {
               print("AVISO: Valor muito baixo para reduzir o Nível de Perigo.", 'color-yellow');
               print(`A eficiência de limpeza é de 1% DANGER a cada ${formatCurrency(LAUNDERING_COST_PER_DANGER_POINT)} investidos.`, 'color-yellow');
               return;
           }

           balance -= cost;
           dangerLevel = Math.max(0, dangerLevel - reduction);

           print(`> [PYTHON SCRIPT] Executando 'trace_cleaner_v3.0' com ${formatCurrency(cost)}...`, 'color-blue');
           print(`...[202 ACCEPTED] ${formatCurrency(cost)} deduzido para anonimato.`, 'color-green');
           print(`...Rastros limpos. REDUÇÃO DE PERIGO: -${reduction}% DANGER.`, 'color-green');
           print(`...PERIGO ATUAL: ${dangerLevel}%`, 'color-yellow');
       }
       
       /**
        * Processa o comando 'upgrade <modulo>'.
        * @param {string[]} args - Argumentos do comando (o modulo).
        */
       function processUpgrade(args) {
           // Checa se há um rastreamento ativo
           if (traceStatus > 0) {
               print("ERRO 0x00A1: OPERAÇÃO BLOQUEADA. Trace Event ativo. Execute 'obfuscate' primeiro.", 'color-red');
               return;
           }

           const moduleName = args[0];
           const module = upgrade[moduleName];

           if (!module) {
               print("ERRO 0x003A: Módulo de upgrade não reconhecido. Use: stealth ou exploit.", 'color-red');
               print("Use 'upgrade' (sem argumentos) para ver a lista.", 'color-white');
               return;
           }

           if (module.level >= module.max) {
               print(`AVISO: Módulo ${module.name} já está no nível máximo (${module.max}).`, 'color-yellow');
               return;
           }
           
           // Custo exponencial
           const cost = Math.floor(module.cost * Math.pow(2, module.level));

           if (balance < cost) {
               print(`ERRO 0x003B: Saldo insuficiente. Requer ${formatCurrency(cost)} para o próximo nível.`, 'color-red');
               return;
           }

           // Executar Upgrade
           balance -= cost;
           module.level += 1;
           
           print(`> [SYSTEM] Instalando UPGRADE ${module.name} - Nível ${module.level}...`, 'color-blue');
           print(`...[200 OK] ${formatCurrency(cost)} deduzido.`, 'color-green');
           print(`...Módulo ${module.name} atualizado para Nível ${module.level}.`, 'color-green');
           
           // Checagem de Desbloqueio (Apenas para Exploit)
           if (moduleName === 'exploit' && module.level === BANK_UNLOCK_LEVEL) {
               print("!!! NOVO ALVO DESBLOQUEADO !!!", 'color-green');
               print("... REQUISITO ATINGIDO: Alvo 'bank' agora está acessível para hack.", 'color-green');
           }


           // Reajusta o custo para o próximo nível (ou exibe a conclusão)
           if (module.level < module.max) {
               const nextCost = Math.floor(module.cost * Math.pow(2, module.level));
               print(`...Próximo custo: ${formatCurrency(nextCost)}.`, 'color-yellow');
           } else {
               print("...Nível máximo alcançado.", 'color-green');
           }
       }
       
       /**
        * Processa o comando 'obfuscate'.
        */
       function processObfuscate() {
           if (traceStatus === 0) {
               print("AVISO: Nenhum Trace Event ativo. Comando 'obfuscate' desnecessário.", 'color-yellow');
               return;
           }

           // Custo baseado no nível de rastreamento
           const cost = TRACE_COST_BASE * traceStatus; 
           
           if (balance < cost) {
               print(`ERRO 0x00A2: Saldo insuficiente. Requer ${formatCurrency(cost)} para iniciar o módulo 'obfuscate'.`, 'color-red');
               return;
           }

           // Chance de sucesso: 70% (base) - Penalidade por Trace (10% ou 20%) + Bônus Stealth (15% por nível)
           const stealthBonus = upgrade.stealth.level * upgrade.stealth.successBonus;
           const tracePenalty = traceStatus * 10;
           const finalSuccessChance = 70 - tracePenalty + stealthBonus; 
           const roll = Math.floor(Math.random() * 100) + 1;

           print(`> [SECURITY] Executando 'obfuscate_v1.0' (Custo: ${formatCurrency(cost)}, Chance: ${finalSuccessChance}%)...`, 'color-blue');
           balance -= cost;

           if (roll < finalSuccessChance) {
               // SUCESSO
               traceStatus = 0;
               dangerLevel = Math.max(0, dangerLevel - 5); // Pequena redução de perigo por limpar rastros
               print("...[200 OK] VETOR DE RASTREIO NEUTRALIZADO.", 'color-green');
               print("...Os dados de intrusão foram corrompidos com sucesso. TRACE LIMPO.", 'color-green');
               print("...PERIGO REDUZIDO EM 5%. Você pode retomar as operações.", 'color-yellow');
           } else {
               // FALHA
               const dangerIncrease = traceStatus * 15; // Aumento de 15% ou 30% no perigo
               dangerLevel = Math.min(MAX_DANGER, dangerLevel + dangerIncrease);
               
               print("...[500 SERVER ERROR] Falha na injeção de dados. O rastro ficou mais forte.", 'color-red');
               print(`...AVISO: O RASTREIO CONTINUA ATIVO! DANGER LEVEL: +${dangerIncrease}%.`, 'color-red');
               
               // Se falhar no Trace Low, pode ir para Trace High
               if (traceStatus === 1) {
                   traceStatus = 2;
                   print("...INTENSIDADE DO TRACE AUMENTADA PARA CRÍTICA!", 'color-red');
               }
           }
       }

       /**
        * Processa a entrada do usuário e executa os comandos.
        * @param {string} input - A string de comando.
        */
       function processCommand(input) {
           try {
               const parts = input.trim().toLowerCase().split(/\s+/);
               const command = parts[0];
               const args = parts.slice(1);

               if (command === '') return;

               // Echo do comando
               print(`USER@PROTOCOL_SHELL: ${input}`, 'color-white'); 
               
               // Checagem de estado principal, que pode bloquear saldo se requisitos não forem atendidos
               checkGameState(); 
               
               if (inputField.disabled) return; // Se o jogo terminou, não processa mais comandos

               switch (command) {
                   case 'help':
                       showHelp();
                       break;
                   case 'status':
                       processStatus();
                       break;
                   case 'hack':
                       processHack(args);
                       break;
                   case 'laundering':
                       processLaundering(args);
                       break;
                   case 'upgrade':
                       if (args.length === 0) {
                           showUpgradeInfo(); 
                       } else {
                           processUpgrade(args); 
                       }
                       break;
                   case 'obfuscate': 
                       processObfuscate();
                       break;
                   case 'clear':
                       outputDiv.innerHTML = '';
                       printInitialMessage();
                       break;
                   case 'exit':
                       print("...Sessão Encerrada pelo Usuário (Exit Code 0).", 'color-blue');
                       inputField.disabled = true;
                       break;
                   default:
                       print(`ERRO 0x0001: Comando não reconhecido: ${command}. Digite 'help'.`, 'color-red');
                       break;
               }

               checkGameState(); // Checa novamente após a execução do comando (especialmente para hacks/upgrades)
           } catch (error) {
               // Mostrar a mensagem de erro real para ajudar no diagnóstico
               print("!!! ERRO CRÍTICO INESPERADO !!! 0xDEADBEEF", 'color-red');
               print(`[SYSTEM LOG]: ${error.message}.`, 'color-red'); 
               print("---", 'color-red');
               print("AVISO: O sistema encontrou um erro de execução. Use 'clear' e tente novamente.", 'color-red');
               console.error("Critical error processing command:", error); 
           }
       }

       /**
        * Manipulador de evento de teclado para o campo de entrada.
        * @param {KeyboardEvent} event - O evento de teclado.
        */
       function handleInput(event) {
           if (event.key === 'Enter') {
               const command = inputField.value;
               inputField.value = ''; 
               processCommand(command);
           }
       }

       /**
        * Mensagem inicial do terminal, imitando um script de inicialização.
        */
       function printInitialMessage() {
           print("================================================", 'color-blue');
           print(`>>> [BOOT_START] ${new Date().toISOString()}`, 'color-blue');
           print("... 0x01: MEMORY_ALLOC = OK", 'color-green');
           print("... 0x02: NETWORK_PING = 78.12.3.99 [SECURE]", 'color-green');
           print(">>> [PROTOCOL 2M] VERSION 4.12.0 (REQUISITOS DE PROGRESSÃO)", 'color-yellow');
           print("---", 'color-white');
           print(">>> [PAYLOAD_INIT] CARREGANDO MÓDULOS DE INTRUSÃO...", 'color-blue');
           print("... module_stealth.py: [200 OK]", 'color-green');
           print("... module_exploit_db.sh: [200 OK]", 'color-green');
           print("... module_trace_cleaner.py: [200 OK]", 'color-green');
           
           // Mensagem Inicial de Metas
           print(`... PRIMEIRA META (TRANSIÇÃO): ${formatCurrency(TRANSITION_TARGET)} (Requer Total de Upgrades Lv. ${TRANSITION_UPGRADE_TOTAL_LEVEL_REQ})`, 'color-yellow');
           print(`... META FINAL (VITÓRIA): ${formatCurrency(WIN_TARGET)} (Requer Upgrades Lv. ${WIN_UPGRADE_LEVEL_REQ} em tudo)`, 'color-yellow');

           print(`... ALVO PRIMÁRIO: CÓDIGO B-79.02 (BANK) - REQUER UPGRADE DE MÓDULO.`, 'color-red'); 
           print(`... COMANDOS ESSENCIAIS: 'hack crypto', 'laundering <valor>', 'obfuscate'.`, 'color-orange'); 
           print(`... CONSULTE UPGRADES E REQUISITOS: 'upgrade' (sem argumentos).`, 'color-yellow'); 

           print("---", 'color-white');
           print("INICIALIZAÇÃO CONCLUÍDA. DIGITE 'help' PARA COMANDOS.", 'color-white');
           print("================================================", 'color-blue');
       }

       // --- Inicialização ---
       window.onload = printInitialMessage;
       
   </script>

</body>
</html>